import { LLMService } from '../../core/llm-service.js';

/**
 * Semaphore for controlling concurrent LLM requests
 */
class Semaphore {
  constructor(capacity) {
    this.capacity = capacity;
    this.current = 0;
    this.queue = [];
  }

  async acquire() {
    return new Promise((resolve) => {
      const release = () => {
        this.current--;
        if (this.queue.length > 0) {
          const next = this.queue.shift();
          next();
        }
      };

      if (this.current < this.capacity) {
        this.current++;
        resolve(release);
      } else {
        this.queue.push(() => {
          this.current++;
          resolve(release);
        });
      }
    });
  }
}

/**
 * Java vulnerability detector using LLM-powered analysis
 */
export class JavaVulnerabilityDetector {
  constructor(config = {}) {
    this.initialized = false;
    this.llmService = null;
    this.maxRetries = config.maxRetries || 3;
    this.timeout = config.timeout || 30000;
  }

  /**
   * Initialize the vulnerability detector
   */
  async initialize() {
    if (this.initialized) return;

    try {
      this.llmService = new LLMService();
      await this.llmService.initialize();
      console.log('[JavaVulnerabilityDetector] LLM service initialized');
      this.initialized = true;
    } catch (error) {
      console.error('[JavaVulnerabilityDetector] LLM initialization failed:', error.message);
      throw new Error(`Failed to initialize LLM service: ${error.message}`);
    }
  }

  /**
   * Analyze parsed Java code for vulnerabilities using LLM with parallel processing
   * @param {object} ast - Abstract syntax tree
   * @param {object} context - Analysis context
   * @returns {Array} Array of vulnerabilities
   */
  async analyze(ast, context) {
    const vulnerabilities = [];
    
    try {
      if (!this.initialized) {
        await this.initialize();
      }

      const concurrencyLimit = 5; // Limit concurrent LLM calls to avoid rate limits

      // Analyze methods in parallel with concurrency limit
      if (ast.methods && ast.methods.length > 0) {
        try {
          const methodVulns = await this.analyzeMethodsInParallel(ast.methods, context, concurrencyLimit);
          vulnerabilities.push(...methodVulns);
        } catch (error) {
          console.error('[JavaVulnerabilityDetector] Error in analyzeMethodsInParallel:', error);
          console.error('[JavaVulnerabilityDetector] Error stack:', error.stack);
          throw error;
        }
      }

      // Analyze full file context if methods don't capture everything
      if (ast.methods.length === 0 || this.shouldAnalyzeFullFile(ast)) {
        try {
          const fileVulns = await this.analyzeFullFileWithLLM(ast, context);
          vulnerabilities.push(...fileVulns);
        } catch (error) {
          console.warn('[JavaVulnerabilityDetector] Full file LLM analysis failed:', error.message);
        }
      }

      console.log(`[JavaVulnerabilityDetector] LLM found ${vulnerabilities.length} vulnerabilities`);
      return this.deduplicateVulnerabilities(vulnerabilities);
    } catch (error) {
      console.error('[JavaVulnerabilityDetector] Error in analyze:', error);
      console.error('[JavaVulnerabilityDetector] Error stack:', error.stack);
      throw error;
    }
  }

  /**
   * Analyze full file with LLM for cases where method-level analysis isn't sufficient
   */
  async analyzeFullFileWithLLM(ast, context) {
    const fileContext = {
      ...context,
      language: 'java',
      analysisType: 'full-file',
      framework: this.detectFrameworkFromAST(ast),
      dependencies: this.extractDependencies(context)
    };

    // Construct file overview for LLM
    const fileOverview = this.constructFileOverview(ast);
    
    try {
      const vulnerabilities = await this.llmService.analyzeVulnerabilities(fileOverview, fileContext);
      
      return vulnerabilities.map(vuln => ({
        ...vuln,
        file: context.filePath,
        relativePath: context.relativePath,
        context: fileContext,
        analysisType: 'llm-full-file',
        owasp: this.mapCWEToOWASP(vuln.cwe)
      }));
    } catch (error) {
      console.warn('[JavaVulnerabilityDetector] Full file LLM analysis failed:', error.message);
      return [];
    }
  }

  /**
   * Determine if full file analysis is needed
   */
  shouldAnalyzeFullFile(ast) {
    if (!ast) return false;
    
    // Analyze full file if there are complex interactions between methods
    // or if there are class-level security concerns
    const hasSecurityImports = ast.imports && Array.isArray(ast.imports) && 
      ast.imports.some(imp => {
        const packageName = imp.packageName || imp.text || '';
        return packageName.includes('security') || 
               packageName.includes('crypto') ||
               packageName.includes('auth');
      });
    
    const hasSecurityClasses = ast.classes && Array.isArray(ast.classes) &&
      ast.classes.some(cls => {
        const interfaces = cls.interfaces || [];
        const annotations = cls.annotations || [];
        return interfaces.some(iface => iface.includes('Security')) ||
               annotations.some(ann => (ann.name || '').includes('Security'));
      });
    
    return hasSecurityImports || hasSecurityClasses;
  }

  /**
   * Construct file overview for LLM analysis
   */
  constructFileOverview(ast) {
    const imports = ast.imports.map(imp => imp.text).join('\n');
    const classes = ast.classes.map(cls => `class ${cls.name} ${cls.superclass ? `extends ${cls.superclass}` : ''}`).join('\n');
    const methods = ast.methods.map(method => {
      const params = method.parameters.map(p => `${p.type} ${p.name}`).join(', ');
      return `${method.returnType} ${method.name}(${params})`;
    }).join('\n');
    
    return `// File Overview
${imports}

${classes}

// Methods:
${methods}

// Key code sections:
${ast.methods.map(m => m.body).join('\n---\n')}`;
  }

  /**
   * Detect framework from AST
   */
  detectFrameworkFromAST(ast) {
    if (!ast || !ast.imports || !Array.isArray(ast.imports)) {
      return 'Java';
    }
    
    const imports = ast.imports.map(imp => imp.packageName || imp.text || '').join(' ');
    
    if (imports.includes('springframework')) return 'Spring Boot';
    if (imports.includes('javax.servlet')) return 'Java Servlet';
    if (imports.includes('javax.persistence')) return 'JPA';
    if (imports.includes('javax.ws.rs')) return 'JAX-RS';
    
    return 'Java';
  }





  /**
   * Analyze multiple methods using batch processing for better efficiency
   * @param {Array} methods - Array of method objects
   * @param {object} context - Analysis context
   * @param {number} concurrencyLimit - Maximum concurrent LLM calls
   * @returns {Array} Array of vulnerabilities from all methods
   */
  async analyzeMethodsInParallel(methods, context, concurrencyLimit = 5) {
    const vulnerabilities = [];
    const startTime = Date.now();
    
    // Use batch processing if we have many methods
    if (methods.length > 6) {
      console.log(`[JavaVulnerabilityDetector] Using batch processing for ${methods.length} methods`);
      
      // Prepare code segments for batch processing
      const codeSegments = methods.map(method => ({
        code: this.constructMethodCode(method),
        context: {
          ...context,
          method: method.name,
          language: 'java',
          framework: this.detectFramework(method),
          dependencies: this.extractDependencies(context)
        }
      }));
      
      // Process in batches
      const batchResults = await this.llmService.analyzeVulnerabilitiesBatch(codeSegments);
      
      // Flatten and enhance results
      for (let i = 0; i < batchResults.length; i++) {
        const methodVulns = batchResults[i];
        const method = methods[i];
        
        const methodCode = this.constructMethodCode(method);
        
        const enhancedVulns = methodVulns.map(vuln => ({
          ...vuln,
          file: context.filePath,
          relativePath: context.relativePath,
          method: method.name,
          evidence: methodCode, // Add evidence
          startLine: method.startLine,
          analysisType: 'llm-batch',
          owasp: this.mapCWEToOWASP(vuln.cwe)
        }));
        
        vulnerabilities.push(...enhancedVulns);
      }
      
    } else {
      // Use parallel processing for smaller numbers of methods
      console.log(`[JavaVulnerabilityDetector] Using parallel processing for ${methods.length} methods`);
      
      const semaphore = new Semaphore(concurrencyLimit);
      
      // Create promises for all method analyses
      const methodPromises = methods.map(method => 
        semaphore.acquire().then(async (release) => {
          try {
            const methodVulns = await this.analyzeMethodWithLLM(method, context);
            return methodVulns;
          } catch (error) {
            console.warn(`[JavaVulnerabilityDetector] LLM analysis failed for method ${method.name}:`, error.message);
            return [];
          } finally {
            release();
          }
        })
      );
      
      // Wait for all method analyses to complete
      const methodResults = await Promise.all(methodPromises);
      
      // Flatten results
      for (const methodVulns of methodResults) {
        vulnerabilities.push(...methodVulns);
      }
    }
    
    const duration = Date.now() - startTime;
    console.log(`[JavaVulnerabilityDetector] Analyzed ${methods.length} methods in ${duration}ms`);
    
    return vulnerabilities;
  }

  /**
   * Analyze method with LLM
   * @param {object} method - Method information
   * @param {object} context - Analysis context
   * @returns {Array} Array of vulnerabilities
   */
  async analyzeMethodWithLLM(method, context) {
    const methodContext = {
      ...context,
      method: method.name,
      language: 'java',
      framework: this.detectFramework(method),
      dependencies: this.extractDependencies(context)
    };

    // Get full method code including signature
    const methodCode = this.constructMethodCode(method);
    
    try {
      const vulnerabilities = await this.llmService.analyzeVulnerabilities(methodCode, methodContext);
      
      // Enhance vulnerabilities with additional context
      return vulnerabilities.map(vuln => ({
        ...vuln,
        file: context.filePath,
        relativePath: context.relativePath,
        method: method.name,
        evidence: methodCode, // Add evidence
        startLine: method.startLine,
        context: methodContext,
        analysisType: 'llm',
        owasp: this.mapCWEToOWASP(vuln.cwe)
      }));
    } catch (error) {
      console.warn(`[JavaVulnerabilityDetector] LLM analysis failed for method ${method.name}:`, error.message);
      return [];
    }
  }


  /**
   * Deduplicate vulnerabilities from different analysis methods
   */
  deduplicateVulnerabilities(vulnerabilities) {
    const seen = new Set();
    const deduplicated = [];

    for (const vuln of vulnerabilities) {
      // Create a unique key based on type, line, and evidence
      const key = `${vuln.type}-${vuln.line || vuln.startLine}-${vuln.evidence?.substring(0, 50) || ''}`;
      
      if (!seen.has(key)) {
        seen.add(key);
        deduplicated.push(vuln);
      }
    }

    return deduplicated;
  }

  /**
   * Construct full method code for LLM analysis
   */
  constructMethodCode(method) {
    const params = method.parameters.map(p => `${p.type} ${p.name}`).join(', ');
    const modifiers = method.modifiers.join(' ');
    const annotations = method.annotations.map(a => a.text).join('\n');
    
    return `${annotations}
${modifiers} ${method.returnType} ${method.name}(${params}) {${method.body}
}`.trim();
  }

  /**
   * Detect framework being used
   */
  detectFramework(method) {
    const annotations = method.annotations ? method.annotations.map(a => a.name).join(' ') : '';
    const body = method.body || '';
    
    if (annotations.includes('RequestMapping') || annotations.includes('GetMapping')) {
      return 'Spring Boot';
    }
    if (body.includes('HttpServlet') || body.includes('javax.servlet')) {
      return 'Java Servlet';
    }
    if (body.includes('javax.persistence') || body.includes('@Entity')) {
      return 'JPA';
    }
    
    return 'Java';
  }

  /**
   * Extract dependencies from context
   */
  extractDependencies(context) {
    // This would be enhanced to parse actual dependencies from pom.xml/build.gradle
    // For now, return common ones
    return ['javax.servlet', 'java.sql', 'java.io'];
  }

  /**
   * Map CWE to OWASP Top 10
   */
  mapCWEToOWASP(cwe) {
    const mapping = {
      89: 'A03:2021', // SQL Injection
      79: 'A03:2021', // XSS
      22: 'A01:2021', // Path Traversal
      78: 'A03:2021', // Command Injection
      502: 'A08:2021', // Insecure Deserialization
      611: 'A05:2021', // XXE
      287: 'A07:2021', // Authentication Bypass
      200: 'A01:2021', // Sensitive Data Exposure
      284: 'A01:2021', // Broken Access Control
      16: 'A05:2021'   // Security Misconfiguration
    };
    
    return mapping[cwe] || 'A06:2021'; // Default to Vulnerable Components
  }

  /**
   * Get AI prompts for semantic analysis
   * @returns {object} AI prompts
   */
  getAIPrompts() {
    return {
      SQL_INJECTION: `
        Analyze this Java method for SQL injection vulnerabilities:
        
        Look for:
        - String concatenation in SQL queries
        - Missing prepared statement parameters
        - Dynamic query construction
        - User input directly in SQL statements
        
        Consider safe patterns:
        - PreparedStatement with parameter binding
        - JPA named parameters
        - Hibernate criteria queries
        
        Return JSON with vulnerability details.
      `,
      XSS: `
        Analyze this Java web method for XSS vulnerabilities:
        
        Look for:
        - Direct output of request parameters
        - Missing output encoding
        - Unsafe JSP/template usage
        
        Consider safe patterns:
        - OWASP ESAPI encoding
        - Spring Security escaping
        - JSP c:out tags
        
        Return JSON with vulnerability details.
      `
    };
  }
}